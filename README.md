# Plutarch UPLC-CAPE Benchmark Submissions

This repository contains Plutarch implementations for the [UPLC-CAPE benchmark](https://github.com/IntersectMBO/UPLC-CAPE), comparing optimized and naive recursive implementations.

## Benchmark Implementations

This project provides 4 different implementations:

1. **factorial** - Optimized factorial using custom `pfix'`
2. **factorial_naive_recursion** - Naive factorial using standard library `pfix`
3. **fibonacci** - Optimized fibonacci using custom `pfix''`
4. **fibonacci_naive_recursion** - Naive fibonacci using standard library `pfix`

## Project Structure

```
.
├── lib/
│   └── Compile.hs           # Shared UPLC compilation library
├── exe/
│   ├── factorial/
│   │   └── Main.hs          # Optimized factorial (custom pfix')
│   ├── factorial-naive/
│   │   └── Main.hs          # Naive factorial (standard pfix)
│   ├── fibonacci/
│   │   └── Main.hs          # Optimized fibonacci (custom pfix'')
│   └── fibonacci-naive/
│       └── Main.hs          # Naive fibonacci (standard pfix)
├── cabal.project            # Cabal project with CHaP configuration
├── plutarch-cape-submissions.cabal  # Package definition with library and 4 executables
├── flake.nix                # Nix flake with haskell.nix
└── .envrc                   # Direnv configuration
```

## Prerequisites

- Nix with flakes enabled
- (Optional) direnv for automatic environment loading

## Building and Running

### Option 1: Using Nix Flakes

1. Enter the development environment:

   ```bash
   nix develop
   ```

2. Update cabal package index (first time only):

   ```bash
   cabal update
   ```

3. Build all executables:

   ```bash
   cabal build all
   ```

4. Run individual executables to generate UPLC files:

   ```bash
   cabal run factorial           # Generates factorial.uplc
   cabal run factorial-naive     # Generates factorial_naive_recursion.uplc
   cabal run fibonacci           # Generates fibonacci.uplc
   cabal run fibonacci-naive     # Generates fibonacci_naive_recursion.uplc
   ```

### Option 2: Using direnv (Automatic)

If you have direnv installed:

1. Allow direnv in this directory:

   ```bash
   direnv allow
   ```

2. The environment will load automatically when you `cd` into the directory

3. Build executables:

   ```bash
   cabal update      # first time only
   cabal build all   # compile all executables
   ```

### Option 3: Using Nix Run

Run executables directly with nix:

```bash
nix run .#factorial
nix run .#factorial-naive
nix run .#fibonacci
nix run .#fibonacci-naive
```

## Generated Output

Running the executables will generate the following UPLC files:

- `factorial.uplc` - Optimized factorial implementation
- `factorial_naive_recursion.uplc` - Naive factorial implementation
- `fibonacci.uplc` - Optimized fibonacci implementation
- `fibonacci_naive_recursion.uplc` - Naive fibonacci implementation

## Architecture

The project separates concerns into:

- **Library (`lib/Compile.hs`)**: Shared UPLC compilation pipeline
  - Compiles Plutarch terms to Plutus Scripts
  - Converts to DeBruijn notation
  - Pretty-prints to UPLC format

- **Executables (`exe/*/Main.hs`)**: Individual algorithm implementations
  - Each in its own directory with `Main.hs`
  - Import and use the shared compilation library
  - Define algorithm-specific combinators and logic

## Dependencies

This project uses:

- **Plutarch v1.11.0** (master): Typed eDSL for writing UPLC
- **Plutus Core v1.51.0.0**: Core Plutus compilation and types
- **CHaP (Cardano Haskell Packages)**: Cardano ecosystem packages
- **haskell.nix**: Nix infrastructure for Haskell projects
- **GHC 9.6.6**: Haskell compiler

## UPLC-CAPE Benchmark

The UPLC-CAPE benchmark aims to compare UPLC programs generated by different compilers and optimization strategies. These implementations serve as Plutarch's contribution to the benchmark.

### Submission Format

For UPLC-CAPE submissions, each implementation should include:
- `*.uplc` - The compiled UPLC program
- `metadata.json` - Compiler and submission details
- `metrics.json` - Performance measurements

## Notes

- The project uses CHaP for Cardano-specific dependencies
- Index state is pinned for reproducibility
- The generated UPLC is in pretty-printed format, not binary
- All implementations compile to standalone UPLC programs suitable for benchmarking
