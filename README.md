# Plutarch UPLC-CAPE Benchmark Submissions

This repository contains Plutarch implementations for the [UPLC-CAPE benchmark](https://github.com/IntersectMBO/UPLC-CAPE), comparing optimized and naive recursive implementations.

## Benchmark Implementations

This project provides 6 different implementations showcasing various optimization strategies:

### Factorial Implementations

1. **factorial-naive** - Baseline implementation
2. **factorial-size** - Optimized for code size
3. **factorial-exbudget** - Optimized for execution budget

### Fibonacci Implementations

4. **fibonacci-naive** - Baseline implementation
5. **fibonacci-size** - Optimized for code size
6. **fibonacci-exbudget** - Optimized for execution budget

## Project Structure

```
.
├── lib/
│   └── Compile.hs           # Shared UPLC compilation library
├── exe/
│   ├── factorial-size/
│   │   └── Main.hs          # Size-optimized factorial
│   ├── factorial-exbudget/
│   │   └── Main.hs          # Budget-optimized factorial
│   ├── factorial-naive/
│   │   └── Main.hs          # Naive factorial baseline
│   ├── fibonacci-size/
│   │   └── Main.hs          # Size-optimized fibonacci
│   ├── fibonacci-exbudget/
│   │   └── Main.hs          # Budget-optimized fibonacci
│   └── fibonacci-naive/
│       └── Main.hs          # Naive fibonacci baseline
├── cabal.project            # Cabal project with CHaP configuration
├── plutarch-cape-submissions.cabal  # Package definition with library and 6 executables
├── flake.nix                # Nix flake with haskell.nix
└── .envrc                   # Direnv configuration
```

## Prerequisites

- Nix with flakes enabled
- (Optional) direnv for automatic environment loading

## Building and Running

### Option 1: Using Nix Flakes

1. Enter the development environment:

   ```bash
   nix develop
   ```

2. Update cabal package index (first time only):

   ```bash
   cabal update
   ```

3. Build all executables:

   ```bash
   cabal build all
   ```

4. Run individual executables to generate UPLC files:

   ```bash
   cabal run factorial-size      # Generates factorial_size.uplc
   cabal run factorial-exbudget  # Generates factorial_exbudget.uplc
   cabal run factorial-naive     # Generates factorial_naive_recursion.uplc
   cabal run fibonacci-size      # Generates fibonacci_size.uplc
   cabal run fibonacci-exbudget  # Generates fibonacci_exbudget.uplc
   cabal run fibonacci-naive     # Generates fibonacci_naive_recursion.uplc
   ```

### Option 2: Using direnv (Automatic)

If you have direnv installed:

1. Allow direnv in this directory:

   ```bash
   direnv allow
   ```

2. The environment will load automatically when you `cd` into the directory

3. Build executables:

   ```bash
   cabal update      # first time only
   cabal build all   # compile all executables
   ```

### Option 3: Using Nix Run

Run executables directly with nix:

```bash
nix run .#factorial-size
nix run .#factorial-exbudget
nix run .#factorial-naive
nix run .#fibonacci-size
nix run .#fibonacci-exbudget
nix run .#fibonacci-naive
```

## Generated Output

Running the executables will generate the following UPLC files:

- `factorial_size.uplc` - Size-optimized factorial
- `factorial_exbudget.uplc` - Budget-optimized factorial
- `factorial_naive_recursion.uplc` - Naive factorial baseline
- `fibonacci_size.uplc` - Size-optimized fibonacci
- `fibonacci_exbudget.uplc` - Budget-optimized fibonacci
- `fibonacci_naive_recursion.uplc` - Naive fibonacci baseline

## Architecture

The project separates concerns into:

- **Library (`lib/Compile.hs`)**: Shared UPLC compilation pipeline
  - Compiles Plutarch terms to Plutus Scripts
  - Converts to DeBruijn notation
  - Pretty-prints to UPLC format

- **Executables (`exe/*/Main.hs`)**: Individual algorithm implementations
  - Each in its own directory with `Main.hs`
  - Import and use the shared compilation library
  - Define algorithm-specific combinators and logic

## Dependencies

This project uses:

- **Plutarch v1.11.0** (master): Typed eDSL for writing UPLC
- **Plutus Core v1.51.0.0**: Core Plutus compilation and types
- **CHaP (Cardano Haskell Packages)**: Cardano ecosystem packages
- **haskell.nix**: Nix infrastructure for Haskell projects
- **GHC 9.6.6**: Haskell compiler

## UPLC-CAPE Benchmark

The UPLC-CAPE benchmark aims to compare UPLC programs generated by different compilers and optimization strategies. These implementations serve as Plutarch's contribution to the benchmark.

### Submission Format

For UPLC-CAPE submissions, each implementation should include:
- `*.uplc` - The compiled UPLC program
- `metadata.json` - Compiler and submission details
- `metrics.json` - Performance measurements

## Notes

- The project uses CHaP for Cardano-specific dependencies
- Index state is pinned for reproducibility
- The generated UPLC is in pretty-printed format, not binary
- All implementations compile to standalone UPLC programs suitable for benchmarking
