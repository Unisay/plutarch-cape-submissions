# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This repository contains Plutarch implementations for the UPLC-CAPE benchmark, which compares UPLC programs generated by different compilers and optimization strategies. The project submits 4 different implementations demonstrating the performance impact of different fixed-point combinators.

## Build System and Environment

### Nix Development Environment

The project uses Nix flakes with haskell.nix for reproducible builds:

```bash
nix develop           # Enter development shell
cabal update          # First time only - fetch CHaP packages
cabal build all       # Build all executables
```

### Building Individual Executables

```bash
cabal build all                    # Build all 4 executables
cabal run factorial                # Run optimized factorial
cabal run factorial-naive          # Run naive factorial
cabal run fibonacci                # Run optimized fibonacci
cabal run fibonacci-naive          # Run naive fibonacci
```

Alternatively, use nix directly:
```bash
nix run .#factorial
nix run .#factorial-naive
nix run .#fibonacci
nix run .#fibonacci-naive
```

## Architecture and Implementation Strategy

### Fixed-Point Combinator Optimization Levels

The project demonstrates three different fixed-point combinator implementations, each with different performance/size trade-offs:

1. **`pfix` (standard library)** - from `Plutarch.Internal.Fix`
   - Slowest runtime performance
   - Smallest code size
   - Used in "naive" implementations as baseline

2. **`pfix'` (custom optimized)** - defined inline in optimized implementations
   ```haskell
   pfix' f = plam (\r -> punsafeCoerce r # r) # plam (\r -> f (punsafeCoerce r # r))
   ```
   - Faster than standard `pfix`
   - Medium code size
   - Used for factorial (single recursive call)

3. **`pfix''` (maximum performance)** - defined inline in optimized implementations
   ```haskell
   pfix'' f = plam (\r -> f (punsafeCoerce r # r))
            # plam (\r -> f (punsafeCoerce r # r))
   ```
   - Fastest runtime performance
   - Largest code size (function duplication)
   - Used for fibonacci (double recursive calls)

### Compilation Pipeline

The shared compilation logic is in `lib/Compile.hs` module:
1. Compile Plutarch term to Plutus Script: `compile mempty <term>`
2. Convert to DeBruijn notation: `unDeBruijnTerm` via `traverseOf progTerm`
3. Pretty-print to UPLC text: `prettyPlcClassic`
4. Write to `.uplc` file

All executables use: `compileToUplc :: ClosedTerm a -> FilePath -> IO ()`

### Key Imports

**Library** (`lib/Compile.hs`):
```haskell
import Control.Lens (traverseOf)
import Plutarch.Internal.Term (ClosedTerm, compile)
```

**Optimized executables** (`exe/factorial/Main.hs`, `exe/fibonacci/Main.hs`):
```haskell
import Compile (compileToUplc)
import Plutarch.Internal.Term (punsafeCoerce)
-- factorial also imports: import PlutusCore qualified as PLC
```

**Naive executables** (`exe/factorial-naive/Main.hs`, `exe/fibonacci-naive/Main.hs`):
```haskell
import Compile (compileToUplc)
import Plutarch.Prelude  -- includes pfix
```

### Output Files

Each executable generates a specific UPLC file:
- `factorial` → `factorial.uplc`
- `factorial-naive` → `factorial_naive_recursion.uplc`
- `fibonacci` → `fibonacci.uplc`
- `fibonacci-naive` → `fibonacci_naive_recursion.uplc`

## Dependencies and Package Management

### CHaP Integration

The project uses CHaP (Cardano Haskell Packages) for Cardano ecosystem dependencies:
- Index state pinned to 2025-07-30 for reproducibility
- Plutarch master (commit `427e49b0cbfd2ff97cdc91522a09e06edd7a7fa6`) pulled directly from GitHub
- Plutus packages constrained to version 1.51.0.0
- Required for: `plutarch`, `plutus-core`, `plutus-tx`, `plutus-ledger-api`

### Key Dependencies
- **Plutarch 1.11.0** (master): Typed eDSL for UPLC generation
- **plutus-core 1.51.0.0**: Core Plutus types and compilation
- **plutus-tx 1.51.0.0**: Plutus Tx compiler
- **plutus-ledger-api 1.51.0.0**: Ledger API types
- **lens**: Used for `traverseOf` in DeBruijn conversion
- **GHC 9.6.6**: Compiler version (managed by haskell.nix)

## Code Structure Patterns

### Project Directory Structure

```
.
├── lib/
│   └── Compile.hs           # Shared UPLC compilation library
└── exe/
    ├── factorial/
    │   └── Main.hs          # Optimized factorial (custom pfix', pif'')
    ├── factorial-naive/
    │   └── Main.hs          # Naive factorial (standard pfix)
    ├── fibonacci/
    │   └── Main.hs          # Optimized fibonacci (custom pfix'')
    └── fibonacci-naive/
        └── Main.hs          # Naive fibonacci (standard pfix)
```

### Module Organization

- **Library** (`lib/Compile.hs`): Shared compilation pipeline used by all executables
- **Executables** (`exe/*/Main.hs`): Each in its own directory, imports `Compile` module

### Custom Primitives in Optimized Versions

Optimized implementations define custom primitives for better performance:
- `pif''` - Conditional without hoisting optimization (factorial only)
- `pfix'` or `pfix''` - Custom fixed-point combinators

Naive implementations use only standard library functions (`pfix`, `pif`).

### Cabal Configuration Structure

The `.cabal` file uses three common stanzas:

1. **`common common-opts`**: Shared by library and all executables
   - GHC warning flags (Wall, Wcompat, Wincomplete-uni-patterns, etc.)
   - Default extensions (ImportQualifiedPost, LambdaCase, OverloadedStrings, RankNTypes, TypeOperators, ScopedTypeVariables)
   - Base dependencies (base, plutarch)

2. **`library`**: Imports common-opts and adds:
   - Dependencies: lens, plutus-core
   - Exposes: Compile module

3. **`common common-exe`**: Shared by all executables
   - Imports common-opts
   - RTS options (-threaded, -rtsopts, -with-rtsopts=-N)
   - Depends on plutarch-cape-submissions library

4. **Each executable**: Imports common-exe and specifies:
   - main-is: Main.hs
   - hs-source-dirs: exe/<name>
   - Additional dependencies if needed (e.g., factorial needs plutus-core)

### Required Language Extensions

The project uses these GHC extensions (all in common-opts):
- **ImportQualifiedPost**: For qualified imports after module name
- **LambdaCase**: For lambda case expressions
- **OverloadedStrings**: For string literals
- **RankNTypes**: For ClosedTerm type (requires higher-rank polymorphism)
- **ScopedTypeVariables**: For type signatures in pattern matches (e.g., `FreeVariableError`)
- **TypeOperators**: For the `:--->` type operator in Plutarch function types

## UPLC-CAPE Submission Context

This project is designed for the UPLC-CAPE benchmark (https://github.com/IntersectMBO/UPLC-CAPE). The benchmark compares:
- Different surface languages compiling to UPLC
- Optimization strategies within the same language
- Performance metrics: CPU units, memory units, script size

The generated `.uplc` files are human-readable pretty-printed format, not binary. For benchmark submission, these would need to be accompanied by `metadata.json` and `metrics.json` files.
